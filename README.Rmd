---
title: "README"
author: "Alexander Ilich"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  github_document:
    pandoc_args: --webtex
---
# MultiscaleDEM

## THIS IS A PRE-RELEASE. IT IS STILL BEING TESTED AND FUNCTIONS MAY RECEIVE MAJOR CHANGES.

[![DOI](https://zenodo.org/badge/353158828.svg)](https://zenodo.org/badge/latestdoi/353158828)


Please cite as

Ilich, Alexander R.; Lecours, Vincent; Misiuk, Benjamin; Murawski, Steven A.; 2021. “MultiscaleDEM”, doi:10.5281/zenodo.5548338. https://github.com/ailich/MultiscaleDEM.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE) #Default chunk options
```

## Purpose

This package calculates multi-scale geomorphometric terrain attributes from regularly gridded DEM/bathymetry rasters.

## Install and Load Package

If you don't already have devtools installed, use the code `install.packages("devtools")`

Then to install this package use the code `devtools::install_github("ailich/MultiscaleDEM")`

## Main Functions

### Slope, Aspect and Curvature

-   `SlopeAspect` calculates multi-scale slope and aspect according to the Misiuk et al (2021) which is a modification of the traditional 3 x 3 slope and aspect algorithms (Fleming and Hoffer, 1979; Horn et al., 1981; Ritter, 1987).

-   `WoodEvans` calculates slope, aspect, curvature, and morphometric features by fitting a quadratic surface to the focal window using ordinary least squares (Wood, 1996). This is similar to [r.param.scale in GRASS GIS](https://grass.osgeo.org/grass80/manuals/r.param.scale.html).

### Rugosity

-   `VRM` - Vector ruggedness measure (Sappington et al. 2007).

-   `SAPA` - Calculates the Surface Area to Planar Area (Jenness, 2004). Additionally, planar area can be corrected for slope (Du Preez 2015). Additionally, a proposed extension to multiple scales is provided by summing the surface areas within the focal window and adjusting the planar area of the focal window using multi-scale slope.

-   `SurfaceArea` - Calculate the surface area of each grid cell (Jenness, 2004). Used within `SAPA`.

-   `AdjSD`- This new proposed rugosity metric modifies the standard deviation of elevation/bathymetry to account for slope. It does this by first fitting a plane to the data in the focal window using ordinary least squares, and then extracting the residuals, and then calculating the standard deviation of the residuals.

![](images/adj_sd.png)

### Relative Position

-   `TPI` - Topographic Position Index (Weiss, 2001)

-   `RDMV` - Relative Difference from Mean Value (Lecours et al., 2017)

## Tutorial

In this tutorial we will calculate various terrain attributes using a 5 x 5 cell rectangular window. Any rectangular odd numbered window size however could be used. Window sizes are specified with a vector of length 2 of `c(n_rows, n_cols)`. If a single number is provided it will be used for both the number of rows and columns.

Load packages

```{r message=FALSE}
library(raster) #Load raster package
library(MultiscaleDEM) #Load MultiscaleDEM package
```

See package help page

```{r eval=FALSE}
help(package="MultiscaleDEM")
```

Read in Data
```{r}
r<- raster(volcano, xmn=0, xmx=ncol(volcano)*10, ymn=0, ymx=nrow(volcano)*10) #Use built in volcano data set
crs(r)<- CRS("+proj=utm +zone=16 +datum=WGS84 +units=m +no_defs") #Give r a projection. This is not the right projection, but some functions currently throw an error if there is no crs.
```

```{r echo= FALSE, message=FALSE}
library(tmap) #For plotting
tm_shape(r, raster.downsample = FALSE)+
  tm_raster(palette = colorRamps::matlab.like(100), style = "cont", legend.reverse = TRUE, title = "")+
  tm_layout(legend.outside=TRUE, main.title= "Elevation")
```

### Slope, Aspect, and Curvature

```{r}
slp_asp<- SlopeAspect(r = r, w = c(5,5), unit = "degrees", method = "queen")
```

```{r echo=FALSE}
slp_asp_list<- vector(mode="list", length = nlayers(slp_asp))
for (i in 1:length(slp_asp_list)) {
  curr_var<- names(slp_asp)[i]
  
  if (grepl(pattern = "(^northness)|(eastness)", curr_var)) {
    breaks<- c(-1,0,1)
    midpoint<- 0
    curr_pal<- c("blue", "gray", "red")
  } else if (grepl(pattern = "aspect", curr_var)) {
    curr_pal<-c("blue", "purple", "red", "orange", "yellow", "green", "cyan", "blue")
    breaks<- c(0,90,180,270,360)
    midpoint<- 180
  } else{
    curr_pal<- colorRamps::matlab.like(100)
    midpoint<- NULL
    breaks<- NULL
  }
  
  slp_asp_list[[i]]<- tm_shape(slp_asp[[i]], raster.downsample = FALSE) +
    tm_raster(palette = curr_pal, style= "cont", title = "", breaks = breaks, midpoint = midpoint, legend.reverse = TRUE)+
      tm_layout(main.title = curr_var, 
      main.title.position = "center",
      main.title.size=0.75)
  }
slp_asp_plot<- tmap_arrange(slp_asp_list, ncol=2)
slp_asp_plot
```

```{r}
WE<- WoodEvans(r, w = c(5,5), unit = "degrees", return_aspect = TRUE, na.rm = TRUE, pad = TRUE)
```

```{r echo= FALSE}
WE_list<- vector(mode="list", length = nlayers(WE))
for (i in 1:length(WE_list)) {
  curr_var<- names(WE)[i]
  
  if (grepl(pattern = "(^Northness)|(Eastness)", curr_var)) {
    breaks<- c(-1,0,1)
    midpoint<- 0
    curr_pal<- c("blue", "gray", "red")
    style<- "cont"
  } else if (grepl(pattern = "Aspect", curr_var)) {
    curr_pal<-c("blue", "purple", "red", "orange", "yellow", "green", "cyan", "blue")
    breaks<- c(0,90,180,270,360)
    midpoint<- 180
    style<- "cont"
    } else if(grepl(pattern = "^Features", curr_var)) {
    curr_pal<- c("gray", "black", "blue", "green", "yellow", "red")
    midpoint<- NULL
    breaks<- NULL
    style<- "cat"
  } else if(grepl(pattern = "Curv", curr_var)){
    curr_pal<- c("blue", "gray", "red")
    style<- "cont"
    midpoint<- 0
  } else{
    curr_pal<- colorRamps::matlab.like(100)
    midpoint<- NULL
    breaks<- NULL
    style<- "cont"}
  
  WE_list[[i]]<- tm_shape(WE[[i]], raster.downsample = FALSE) +
    tm_raster(palette = curr_pal, style= style, title = "", breaks = breaks, midpoint = midpoint, legend.reverse = TRUE)+
      tm_layout(main.title = curr_var, 
      main.title.position = "center",
      main.title.size=0.75)
}
WE_plot<- tmap_arrange(WE_list, ncol=4)
WE_plot
```
### Rugosity

```{r}
vrm<- VRM(r, w=c(5,5))
```

```{r echo=FALSE}
tm_shape(vrm, raster.downsample = FALSE)+
  tm_raster(palette = colorRamps::matlab.like(100), style = "cont", legend.reverse = TRUE, title="")+
  tm_layout(legend.outside = TRUE, main.title="VRM")
```

Note: multi-scale SAPA is experimental. The established metric by De Preez (2015) would use `w=1`.
```{r}
sapa<- SAPA(r, w=c(5,5), slope_correction = TRUE)
```

```{r echo=FALSE}
tm_shape(sapa, raster.downsample = FALSE)+
  tm_raster(palette = colorRamps::matlab.like(100), style = "cont", legend.reverse = TRUE, title="")+
  tm_layout(legend.outside = TRUE, main.title="SAPA")
```
```{r}
adj_SD<- AdjSD(r, w=c(5,5), na.rm = TRUE, pad=TRUE)
```

```{r echo=FALSE}
tm_shape(adj_SD, raster.downsample = FALSE)+
  tm_raster(palette = colorRamps::matlab.like(100), style = "cont", legend.reverse = TRUE, title="")+
  tm_layout(legend.outside = TRUE, main.title="Adjusted SD")
```

### Relative Position
```{r}
tpi<- TPI(r, w=c(5,5), na.rm = TRUE, pad = TRUE)
```

```{r echo=FALSE}
tm_shape(tpi, raster.downsample = FALSE)+
  tm_raster(palette = c("blue", "gray", "red"), style = "cont", midpoint=0, legend.reverse = TRUE, title="")+
  tm_layout(legend.outside = TRUE, main.title="TPI")
```
```{r}
rdmv<- RDMV(r, w=c(5,5), na.rm = TRUE, pad = TRUE)
```

```{r echo=FALSE}
tm_shape(rdmv, raster.downsample = FALSE)+
  tm_raster(palette = c("blue", "gray", "red"), style = "cont", midpoint=0, legend.reverse = TRUE, title="")+
  tm_layout(legend.outside = TRUE, main.title="RDMV")
```

# References

Du Preez, C., 2015. A new arc–chord ratio (ACR) rugosity index for quantifying three-dimensional landscape structural complexity. Landscape Ecol 30, 181–192. https://doi.org/10.1007/s10980-014-0118-8

Fleming, M.D., Hoffer, R.M., 1979. Machine processing of landsat MSS data and DMA topographic data for forest cover type mapping (No. LARS Technical Report 062879). Laboratory for Applications of Remote Sensing, Purdue University, West Lafayette, Indiana.

Horn, B.K., 1981. Hill Shading and the Reflectance Map. Proceedings of the IEEE 69, 14–47.

Jenness, J.S., 2004. Calculating landscape surface area from digital elevation models. Wildlife Society Bulletin 32, 829–839. https://doi.org/10.2193/0091-7648(2004)032[0829:CLSAFD]2.0.CO;2

Lecours, V., Devillers, R., Simms, A.E., Lucieer, V.L., Brown, C.J., 2017. Towards a Framework for Terrain Attribute Selection in Environmental Studies. Environmental Modelling & Software 89, 19–30. https://doi.org/10.1016/j.envsoft.2016.11.027

Misiuk, B., Lecours, V., Dolan, M.F.J., Robert, K., 2021. Evaluating the Suitability of Multi-Scale Terrain Attribute Calculation Approaches for Seabed Mapping Applications. Marine Geodesy 44, 327–385. https://doi.org/10.1080/01490419.2021.1925789

Ritter, P., 1987. A vector-based slope and aspect generation algorithm. Photogrammetric Engineering and Remote Sensing 53, 1109–1111.

Weiss, A., 2001. Topographic Position and Landforms Analysis. Presented at the ESRI user conference, San Diego, CA.

Wood, J., 1996. The geomorphological characterisation of digital elevation models (Ph.D.). University of Leicester.


